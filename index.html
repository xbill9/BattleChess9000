<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Mobile-friendly viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini Battle Chess - Powered by Google Gemini, Nano Banana 3, and Veo3</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        
        .ui-layer { position: absolute; width: 100%; text-align: center; pointer-events: none; z-index: 10; }
        #hud { top: 20px; }
        h1 { margin: 0; color: #fff; text-transform: uppercase; letter-spacing: 4px; font-size: 24px; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        #status { color: #aaa; margin-top: 5px; font-size: 16px; font-weight: bold; }
        #player-display { color: #444; font-size: 14px; margin-top: 5px; font-family: monospace; letter-spacing: 1px;}

        /* CHECK ALERT */
        #check-alert { 
            display: none; 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 100px; font-weight: 900; color: red; 
            text-shadow: 0 0 20px black; border: 5px solid red; padding: 20px 50px; 
            background: rgba(0,0,0,0.7); z-index: 500;
            animation: pulse-alert 0.5s infinite alternate;
            pointer-events: none;
        }
        @keyframes pulse-alert { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.1); } }

        /* CAPTURE TRACKER */
        .tracker { 
            position: absolute; top: 100px; width: 50px; bottom: 100px;
            display: flex; flex-direction: column; gap: 5px; padding: 10px; 
            pointer-events: none; z-index: 5;
        }
        .tracker-left { left: 10px; align-items: flex-start; }
        .tracker-right { right: 10px; align-items: flex-end; }
        
        .capture-icon { 
            width: 45px; height: 45px; object-fit: contain; 
            filter: drop-shadow(0 0 2px rgba(255,255,255,0.5));
            transition: transform 0.2s;
        }
        .capture-icon:hover { transform: scale(1.5); }

        /* MODALS */
        .modal { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.95); z-index: 2000; 
            display: none; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; overflow-y: auto;
        }
        .modal.active { display: flex; }
        
        .menu-box { 
            background: #1a1a1a; padding: 40px; border: 1px solid #333; 
            box-shadow: 0 0 50px rgba(0,0,0,1); text-align: center; border-radius: 8px;
            max-width: 500px; width: 90%;
            position: relative;
        }

        /* END GAME SCROLLABLE CONTENT */
        .endgame-content {
            max-height: 80vh;
            overflow-y: auto;
            text-align: left;
            padding-right: 10px;
        }

        /* Scrollbar styling */
        .endgame-content::-webkit-scrollbar { width: 8px; }
        .endgame-content::-webkit-scrollbar-track { background: #111; }
        .endgame-content::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        
        select, button, input[type="text"], .toggle-group { 
            display: block; width: 100%; padding: 10px; margin: 10px 0; box-sizing: border-box;
            font-size: 16px; background: #333; color: white; border: 1px solid #555; 
            cursor: pointer; 
        }
        input[type="text"] { cursor: text; text-align: center; font-weight: bold; border: 1px solid #444; }
        input[type="text"]:focus { outline: none; border-color: #28a745; }

        button { background: #444; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        button:hover { background: #666; }
        .toggle-group { display: flex; gap: 10px; background: transparent; border: none; padding: 0; }
        .toggle-btn { flex: 1; background: #222; border: 1px solid #444; padding: 15px; }
        .toggle-btn.active { background: #eee; color: black; border-color: white; }

        .promo-options { display: flex; gap: 20px; margin-top:20px; justify-content: center;}
        .promo-piece { 
            width: 60px; height: 60px; background: #333; border: 2px solid #555;
            display: flex; align-items: center; justify-content: center;
            font-size: 30px; cursor: pointer; color: #fff;
        }
        .promo-piece:hover { background: #555; border-color: white; }

        /* PROMPTS DISPLAY */
        .prompt-block {
            background: #000; border: 1px solid #333; padding: 15px; margin-bottom: 20px;
            font-family: monospace; font-size: 12px; color: #0f0; white-space: pre-wrap;
            text-align: left;
        }
        h3 { border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 30px; color: #ddd; }
        p { line-height: 1.6; color: #bbb; }
        .highlight { color: #fff; font-weight: bold; }
        a { color: #4da6ff; text-decoration: none; }
        a:hover { text-decoration: underline; }

        #battle-overlay { 
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: black; z-index: 1000;
            flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        video { width: 100%; height: 80%; object-fit: contain; }
        #video-msg { color: #ff5555; font-family: monospace; font-size: 18px; margin-bottom: 20px; }
        #skip-btn { width: auto; display: inline-block; background: transparent; border: 2px solid white; margin-top: 20px; }
        #skip-btn:hover { background: white; color: black; }

        /* --- MOBILE / RESPONSIVE STYLES --- */
        @media (max-width: 768px) {
            /* Shrink the HUD text */
            h1 { font-size: 16px; letter-spacing: 2px; }
            #status { font-size: 14px; }
            #player-display { font-size: 12px; }

            /* Make modals fit nicely on phone screens */
            .menu-box { 
                width: 95%; 
                padding: 15px; 
                max-height: 95vh; 
                overflow-y: auto;
            }
            
            /* Adjust buttons and inputs for touch targets */
            button, select, input[type="text"], .toggle-btn {
                padding: 15px;
                font-size: 14px;
            }

            /* Move Capture Trackers to bottom to save side-width */
            .tracker {
                flex-direction: row;
                width: 100%;
                height: 40px;
                top: auto;
                bottom: 10px;
                padding: 0;
                justify-content: center;
                gap: 5px;
            }
            .tracker-left { left: 0; bottom: 50px; align-items: center; }
            .tracker-right { right: 0; bottom: 10px; align-items: center; }
            
            .capture-icon { width: 35px; height: 35px; }

            /* Resize the massive CHECK alert */
            #check-alert {
                font-size: 40px;
                padding: 10px 20px;
                border-width: 3px;
                width: 80%;
                text-align: center;
            }

            /* Make promotion pieces tappable */
            .promo-piece { width: 50px; height: 50px; font-size: 25px; }
            
            .endgame-content { max-height: 60vh; }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
</head>
<body>

    <!-- START MENU -->
    <div id="start-menu" class="modal active">
        <div class="menu-box">
            <!-- INSPIRATION IMAGE -->
            <img src="battle_chess_1988.png" alt="1988 Inspiration" style="max-width: 100%; max-height: 180px; margin-bottom: 15px; border-radius: 4px; border: 1px solid #444; box-shadow: 0 0 15px rgba(0,0,0,0.8);">
            
            <h2 style="margin-top:0; margin-bottom: 5px;">BATTLE CHESS 9000</h2>
            <p style="color: #666; font-size: 13px; font-style: italic; margin-top: 0; margin-bottom: 20px;">
                Inspired by Battle Chess for DOS 1988
            </p>
            
            <input type="text" id="player-name-input" placeholder="ENTER YOUR NAME" maxlength="15">
            
            <label style="margin-top: 20px;">Select Theme</label>
            <select id="theme-select"><option disabled selected value="">Loading themes...</option></select>
            
            <label style="margin-top:15px; display:block">Play As</label>
            <div class="toggle-group" id="color-toggle-group">
                <button class="toggle-btn active" onclick="setPlayerColor('w')">White</button>
                <button class="toggle-btn" onclick="setPlayerColor('b')">Black</button>
            </div>

            <label style="margin-top:15px; display:block">Mode</label>
            <div class="toggle-group" id="mode-toggle-group">
                <button class="toggle-btn active" onclick="setGameMode('ai')">Vs AI</button>
                <button class="toggle-btn" onclick="setGameMode('pvp')">Vs Friend (Online)</button>
            </div>

            <button onclick="startGame()" style="margin-top:20px; background: #28a745; border:none;">Start Battle</button>
        </div>
    </div>

    <!-- PROMOTION MENU -->
    <div id="promo-modal" class="modal">
        <div class="menu-box">
            <h2>Promote Pawn</h2>
            <div class="promo-options">
                <div class="promo-piece" onclick="commitPromotion('q')">♕</div>
                <div class="promo-piece" onclick="commitPromotion('r')">♖</div>
                <div class="promo-piece" onclick="commitPromotion('b')">♗</div>
                <div class="promo-piece" onclick="commitPromotion('n')">♘</div>
            </div>
        </div>
    </div>

    <!-- GAME OVER / INFO MODAL -->
    <div id="game-over-modal" class="modal">
        <div class="menu-box" style="width: 800px; max-width: 95%;">
            <div class="endgame-content">
                <h1 id="end-title" style="text-align: center; color: #28a745;">GAME OVER</h1>
                <p id="end-reason" style="text-align: center; font-size: 18px; margin-bottom: 30px;"></p>

                <div style="background: #222; padding: 20px; border-left: 4px solid #4da6ff; margin-bottom: 20px;">
                    <p style="margin-top:0; font-style: italic;">
                        "This game was fully vibe coded over an afternoon with <strong>Gemini-3, Nano Banana 3, and Veo3</strong> plus an API key."
                    </p>
                    <p>
                        Did you enjoy your Battle Chess experience? Did the animations live up to your expectations?
                    </p>
                    <p style="font-weight: bold; color: white;">
                        Please write up your experience in a Tweet, LinkedIn post, or Blog! Share with your kids, friends, and colleagues.
                    </p>
                </div>

                <h3>How It Was Made (The Prompts)</h3>
                <p>Want to fork this? Run the asset-generator in the repo and use these exact prompts to recreate this theme:</p>
                
                <p class="highlight">1. Theme Title:</p>
                <div class="prompt-block">medieval_classic</div>

                <p class="highlight">2. Board Style:</p>
                <div class="prompt-block">Medeival 1600s castles with white marble and black obsidian as classical a chessboard you can make with these matierals at the time. Do NOT display pieces just the board and its polished matierals of marble and black obsidian.</div>

                <p class="highlight">3. Piece Style:</p>
                <div class="prompt-block">"These are chess pieces in a set. Do not deviate from classic chess pieces but be creative. The Pawns should be peasants or orcs not just chess pawns. As with the rest of the pieces. 1600s medieval European style with White as holy good and Black as gothic evil, showing a noble crowned king, regal robed queen, Catholic bishops with mitres, armored knights on warhorses, fortified stone castle rooks, and simple foot-soldier pawns for White, versus a dark overlord king with spiked crown, sinister robed queen, corrupted plague-priest bishops, skeletal or demonic knights on shadow steeds, dragon-tower rooks with infernal accents, and ragged disposable pawns for Black, all rendered individually in hand-painted medieval illustration style with clear chess silhouettes, high detail, dramatic shading, parchment background, 1:1 aspect ratio, and consistent lighting. IMPORTANT use highly detailed white marble with gold accents for white pieces and black obsidian with dark silver accents for black pieces. They should be highly detailed and look like they were carved from those materials and polished to a high shine. DO NOT MAKE CARTOONS"</div>

                <p class="highlight">4. Animation Style:</p>
                <div class="prompt-block">"Create ultra-violent Excalibur-1980-style medieval fantasy battle animations showing chess pieces as armored warriors made of metal, bone, and enchanted stone brutally hacking, cleaving, crushing, and shattering each other during captures—for example pawns hacking down pawns, knights impaling pawns, rooks smashing queens, bishops cleaving rooks—rendered with hyper-stylized metallic blood-spray, glowing runic energy bursts, slow-motion sword impacts, shattered armor fragments, fog-soaked battle lighting, heavy chromatic bloom, mythic brutality, and the dark, operatic, blood-drenched tone of John Boorman’s Excalibur. IMPORTANT ALWAYS source the characters from the images do not change their appearance or style. These are medieval fantasy chess pieces NOT generic fantasy characters. DO NOT make cartoons or low detail images. Use highly detailed realistic textures and lighting. DO NOT use modern weapons or technology. ONLY the weapons the piece is holding."</div>

                <hr style="border-color: #333; margin: 30px 0;">

                <div style="text-align: center;">
                    <p><strong>Fork the Repo:</strong> <br> <a href="https://github.com/automateyournetwork/BattleChess9000" target="_blank">github.com/automateyournetwork/BattleChess9000</a></p>
                    <p><strong>Contact:</strong> <br> <a href="mailto:ptcapo@gmail.com">ptcapo@gmail.com</a></p>
                    <button onclick="location.reload()" style="margin-top: 20px;">Play Again</button>
                </div>
            </div>
        </div>
    </div>

    <div id="hud" class="ui-layer">
        <h1>Battle Chess AI</h1>
        <div id="player-display"></div>
        <div id="status">Waiting for game start...</div>

        <!-- Share link for online mode -->
        <div id="share-link-wrapper" style="margin-top:10px; display:none; pointer-events:auto;">
            <span style="color:#888; font-size:12px; display:block;">Send this link to your friend:</span>
            <div style="display:flex; justify-content:center; gap:6px; margin-top:5px;">
                <input id="share-link-input"
                       readonly
                       style="padding:5px; font-size:12px; width:70%; max-width:420px; text-align:center; border-radius:4px; border:1px solid #444; background:#111; color:#ccc;"
                       onclick="this.select();">
                <button id="copy-link-btn"
                        style="padding:5px 10px; font-size:12px; border-radius:4px; border:1px solid #555; background:#333; color:#eee; cursor:pointer; pointer-events:auto;"
                        onclick="copyShareLink()">Copy</button>
            </div>
            <div id="copy-link-status" style="color:#5ccc5c; font-size:11px; margin-top:3px;"></div>
        </div>
    </div>

    <div id="check-alert">CHECK!</div>

    <div id="tracker-w" class="tracker tracker-left"></div>
    <div id="tracker-b" class="tracker tracker-right"></div>

    <div id="battle-overlay">
        <div id="video-msg"></div>
        <video id="battle-video" playsinline></video>
        <button id="skip-btn">Skip Animation</button>
    </div>

    <script>
        let CURRENT_THEME = '';
        let PLAYER_COLOR = 'w';
        let PLAYER_NAME = 'Guest';

        // Game modes
        let GAME_MODE = 'ai';      // 'ai' or 'pvp'
        let ROOM_ID = null;
        let IS_HOST = false;
        let socket = null;
        let joinTimeout = null;
        const JOIN_TIMEOUT_MS = 180000; // 180 seconds

        // TODO: replace with your Cloud Run WebSocket endpoint
        const WS_URL = "wss://battlechess9000-multiplayer-service-960937205198.us-central1.run.app";

        const BOARD_SQUARE_SIZE = 10;
        const BOARD_OFFSET = (8 * BOARD_SQUARE_SIZE) / 2 - (BOARD_SQUARE_SIZE / 2);
        let ASSETS_PATH = '';

        const game = new Chess();
        let selectedSquare = null;
        let selectedMesh = null;
        let isAIThinking = false;
        let pendingPromotionMove = null;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 40, 300);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const spotLight = new THREE.SpotLight(0xffffff, 1.2);
        spotLight.position.set(30, 100, 30);
        spotLight.castShadow = true;
        scene.add(spotLight);

        const textureLoader = new THREE.TextureLoader();
        const piecesMap = {};
        const pieceCache = {};

        window.onload = function() { loadThemes(); };

        function loadThemes() {
            fetch('assets/themes.json')
                .then(r => {
                    if (!r.ok) throw new Error("Manifest not found");
                    return r.json();
                })
                .then(themes => {
                    const sel = document.getElementById('theme-select');
                    sel.innerHTML = '';
                    if(themes.length === 0) {
                        const opt = document.createElement('option'); opt.text = "No themes found"; sel.add(opt); return;
                    }
                    themes.forEach(t => {
                        const opt = document.createElement('option'); opt.value = t; opt.text = t.replace(/_/g, ' ').toUpperCase(); sel.add(opt);
                    });
                    sel.value = themes[themes.length-1];
                })
                .catch(e => {
                    console.error("Theme Load Error:", e);
                    const sel = document.getElementById('theme-select');
                    sel.innerHTML = '<option disabled selected value="">Generate assets first!</option>';
                });
        }

        function setGameMode(mode) {
            GAME_MODE = mode;
            const modeGroup = document.getElementById('mode-toggle-group');
            if (!modeGroup) return;
            const btns = modeGroup.querySelectorAll('.toggle-btn');
            btns.forEach(b => b.classList.remove('active'));
            if (mode === 'ai') {
                btns[0].classList.add('active');
                document.getElementById('share-link-wrapper').style.display = 'none';
            } else {
                btns[1].classList.add('active');
            }
        }

        function refreshColorToggleUI() {
            const group = document.getElementById('color-toggle-group');
            if (!group) return;
            const btns = group.querySelectorAll('.toggle-btn');
            btns.forEach(b => b.classList.remove('active'));
            if (PLAYER_COLOR === 'w') btns[0].classList.add('active');
            else btns[1].classList.add('active');
        }

        function setPlayerColor(c) {
            PLAYER_COLOR = c;
            refreshColorToggleUI();
        }

        function startGame() {
            const sel = document.getElementById('theme-select');
            const nameInput = document.getElementById('player-name-input');
            
            if(!sel.value || sel.value === "") {
                alert("Please select a valid theme. If none appear, run asset_generator.py first!");
                return;
            }

            PLAYER_NAME = nameInput.value.trim() || "Commander";
            document.getElementById('player-display').innerText = `COMMANDER: ${PLAYER_NAME.toUpperCase()}`;

            CURRENT_THEME = sel.value;
            ASSETS_PATH = `assets/${CURRENT_THEME}/`;
            
            document.getElementById('start-menu').classList.remove('active');
            
            buildSimpleBoard();
            initPieces();

            const isMobile = window.innerWidth < 768;

            // Initial camera orientation based on currently selected color
            if (PLAYER_COLOR === 'w') { 
                const zPos = isMobile ? 110 : 80;
                const yPos = isMobile ? 80 : 60;
                camera.position.set(0, yPos, zPos); 
                camera.lookAt(0,0,0); 
            } else { 
                const zPos = isMobile ? -110 : -80;
                const yPos = isMobile ? 80 : 60;
                camera.position.set(0, yPos, zPos); 
                camera.lookAt(0,0,0); 
                controls.target.set(0,0,0); 
            }

            updateStatus();

            if (GAME_MODE === 'pvp') {
                setupMultiplayerRoom();
            } else {
                // Vs AI
                if(PLAYER_COLOR === 'b') setTimeout(makeAIMove, 1000);
            }
        }

        function copyShareLink() {
            const input = document.getElementById('share-link-input');
            const status = document.getElementById('copy-link-status');
            if (!input || !input.value) return;
        
            // Select the text for older browsers
            input.select();
            input.setSelectionRange(0, 99999);
        
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(input.value).then(() => {
                    status.innerText = "Link copied!";
                    setTimeout(() => { status.innerText = ""; }, 2000);
                }).catch(() => {
                    document.execCommand('copy');
                    status.innerText = "Link copied!";
                    setTimeout(() => { status.innerText = ""; }, 2000);
                });
            } else {
                document.execCommand('copy');
                status.innerText = "Link copied!";
                setTimeout(() => { status.innerText = ""; }, 2000);
            }
        }
        
        function setupMultiplayerRoom() {
            const url = new URL(window.location.href);
            const existingRoom = url.searchParams.get('room');

            if (existingRoom) {
                // JOINER
                ROOM_ID = existingRoom;
                IS_HOST = false;
                document.getElementById('status').innerText = "Joining your friend's game...";
                document.getElementById('share-link-wrapper').style.display = 'none';
            } else {
                // HOST
                ROOM_ID = Math.random().toString(36).substring(2, 8).toUpperCase();
                IS_HOST = true;
                            
                // include the CURRENT_THEME in the link
                url.searchParams.set('room', ROOM_ID);
                if (CURRENT_THEME) {
                    url.searchParams.set('theme', CURRENT_THEME);
                }
                const shareLink = url.toString();
                const shareInput = document.getElementById('share-link-input');
                shareInput.value = shareLink;
                document.getElementById('share-link-wrapper').style.display = 'block';

                document.getElementById('status').innerText = "Share the link and waiting for your friend to join...";
            }

            initMultiplayerConnection();
        }

        function initMultiplayerConnection() {
            if (!WS_URL || WS_URL.includes("YOUR-WEBSOCKET-ENDPOINT")) {
                console.warn("WS_URL is not set. Multiplayer won't work until you configure it.");
                document.getElementById('status').innerText = "Multiplayer not configured. Falling back to VS AI.";
                GAME_MODE = 'ai';
                document.getElementById('share-link-wrapper').style.display = 'none';
                if (PLAYER_COLOR === 'b') setTimeout(makeAIMove, 1000);
                return;
            }

            socket = new WebSocket(WS_URL);

            socket.onopen = () => {
                socket.send(JSON.stringify({
                    type: 'join',
                    roomId: ROOM_ID,
                    name: PLAYER_NAME
                }));

                if (IS_HOST) {
                    joinTimeout = setTimeout(() => {
                        alert("No one joined your room within 3 minutes. Switching to VS AI mode.");
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            socket.close();
                        }
                        socket = null;
                        GAME_MODE = 'ai';
                        document.getElementById('share-link-wrapper').style.display = 'none';
                        document.getElementById('status').innerText = "No player joined. VS AI mode activated.";
                        if (PLAYER_COLOR === 'b' && !game.game_over()) {
                            setTimeout(makeAIMove, 1000);
                        }
                    }, JOIN_TIMEOUT_MS);
                } else {
                    document.getElementById('status').innerText = "Connected. Waiting for host to start...";
                }
            };

            socket.onmessage = (event) => {
                const msg = JSON.parse(event.data);

                if (msg.type === 'start') {
                    // Server randomizes colors; we obey
                    if (joinTimeout) clearTimeout(joinTimeout);
                    PLAYER_COLOR = msg.color; // 'w' or 'b'
                    refreshColorToggleUI();

                    // Re-orient camera based on assigned color
                    const isMobile = window.innerWidth < 768;
                    if (PLAYER_COLOR === 'w') {
                        const zPos = isMobile ? 110 : 80;
                        const yPos = isMobile ? 80 : 60;
                        camera.position.set(0, yPos, zPos);
                        camera.lookAt(0,0,0);
                    } else {
                        const zPos = isMobile ? -110 : -80;
                        const yPos = isMobile ? 80 : 60;
                        camera.position.set(0, yPos, zPos);
                        camera.lookAt(0,0,0);
                        controls.target.set(0,0,0);
                    }

                    document.getElementById('status').innerText = 
                        "Game started! " + (game.turn() === 'w' ? 'White' : 'Black') + " to move.";
                } else if (msg.type === 'move') {
                    const move = msg.move;
                    game.move(move);
                    handleMoveVisuals(move, () => {
                        updateStatus();
                    });
                } else if (msg.type === 'error') {
                    alert(msg.message || "Multiplayer error");
                    document.getElementById('status').innerText = "Multiplayer error.";
                }
            };

            socket.onclose = () => {
                if (!game.game_over() && GAME_MODE === 'pvp') {
                    document.getElementById('status').innerText = "Connection lost.";
                }
            };

            socket.onerror = (err) => {
                console.error("WebSocket error", err);
                if (GAME_MODE === 'pvp') {
                    document.getElementById('status').innerText = "WebSocket error.";
                }
            };
        }

        function buildSimpleBoard() {
            const boardTexture = textureLoader.load(ASSETS_PATH + 'board_texture.png', (tex) => { tex.encoding = THREE.sRGBEncoding; });
            const boardGeo = new THREE.BoxGeometry(84, 1, 84);
            const boardMat = new THREE.MeshStandardMaterial({ map: boardTexture, color: 0xffffff });
            const board = new THREE.Mesh(boardGeo, boardMat);
            board.position.y = -0.5;
            board.receiveShadow = true;
            scene.add(board);
        }

        function squareToVector(square) {
            const file = square.charCodeAt(0) - 97;
            const rank = 8 - parseInt(square[1]);  
            const x = (file * BOARD_SQUARE_SIZE) - BOARD_OFFSET;
            const z = (rank * BOARD_SQUARE_SIZE) - BOARD_OFFSET;
            return new THREE.Vector3(x, 5.5, z);
        }

        function getFullName(type, color) {
            const names = { 'p': 'pawn', 'n': 'knight', 'b': 'bishop', 'r': 'rook', 'q': 'queen', 'k': 'king' };
            const c = color === 'w' ? 'white' : 'black';
            return `${c}_${names[type]}`;
        }

        function loadChromaTexture(name, path, color) {
            if (pieceCache[name]) return pieceCache[name];
            const tex = new THREE.Texture();
            const img = new Image();
            img.src = path;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width; canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const d = idata.data;
                for(let i=0; i<d.length; i+=4) {
                    const r=d[i], g=d[i+1], b=d[i+2];
                    if (color === 'w') { if(r < 40 && g < 40 && b < 40) d[i+3] = 0; } 
                    else { if(r > 215 && g > 215 && b > 215) d[i+3] = 0; }
                }
                ctx.putImageData(idata, 0, 0);
                tex.image = canvas; tex.needsUpdate = true; tex.encoding = THREE.sRGBEncoding;
            };
            pieceCache[name] = tex;
            return tex;
        }

        function getTransparentIconUrl(path, color, callback) {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = path;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width; canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const d = idata.data;
                for(let i=0; i<d.length; i+=4) {
                    const r=d[i], g=d[i+1], b=d[i+2];
                    if (color === 'w') { if(r < 40 && g < 40 && b < 40) d[i+3] = 0; } 
                    else { if(r > 215 && g > 215 && b > 215) d[i+3] = 0; }
                }
                ctx.putImageData(idata, 0, 0);
                callback(canvas.toDataURL());
            };
        }

        function spawnPiece(type, color, square) {
            const fname = getFullName(type, color);
            const path = `${ASSETS_PATH}pieces/${fname}.png`;
            const texture = loadChromaTexture(fname, path, color);
            const geometry = new THREE.PlaneGeometry(11.5, 11.5);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, transparent: true, side: THREE.DoubleSide, depthWrite: false 
            });
            const mesh = new THREE.Mesh(geometry, material);
            const pos = squareToVector(square);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.userData = { type: type, color: color, square: square };
            scene.add(mesh);
            piecesMap[square] = mesh;
        }

        function initPieces() {
            const boardState = game.board();
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = boardState[r][c];
                    if (p) spawnPiece(p.type, p.color, String.fromCharCode(97 + c) + (8 - r));
                }
            }
        }

        function updateCaptures(capturedPiece, capturerColor) {
            const fullPieceName = getFullName(capturedPiece, capturerColor === 'w' ? 'b' : 'w');
            const iconPath = `${ASSETS_PATH}pieces/${fullPieceName}.png`;
            const pieceColor = capturerColor === 'w' ? 'b' : 'w';
            
            getTransparentIconUrl(iconPath, pieceColor, (dataUrl) => {
                const img = document.createElement('img');
                img.src = dataUrl;
                img.className = 'capture-icon';
                const containerId = capturerColor === 'w' ? 'tracker-w' : 'tracker-b';
                document.getElementById(containerId).appendChild(img);
            });
        }

        // --- UNIFIED INPUT HANDLING (MOUSE + TOUCH + PEN) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const inputState = {
            isPointerDown: false,
            startX: 0,
            startY: 0
        };

        renderer.domElement.addEventListener('pointerdown', (e) => {
            // Only react to primary button / touch
            if (e.button !== undefined && e.button !== 0) return;
            inputState.isPointerDown = true;
            inputState.startX = e.clientX;
            inputState.startY = e.clientY;
        });

        renderer.domElement.addEventListener('pointerup', (e) => {
            if (!inputState.isPointerDown) return;
            inputState.isPointerDown = false;

            const dx = e.clientX - inputState.startX;
            const dy = e.clientY - inputState.startY;
            const dist = Math.sqrt(dx * dx + dy * dy);

            const threshold = (e.pointerType === 'touch') ? 12 : 5;

            if (dist < threshold) {
                onInteraction(e.clientX, e.clientY);
            }
        });

        function onInteraction(clientX, clientY) {
            if(document.getElementById('battle-overlay').style.display === 'flex') return;
            if(isAIThinking || game.game_over() || game.turn() !== PLAYER_COLOR) return;

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);

            const pieceIntersects = raycaster.intersectObjects(Object.values(piecesMap));
            if (pieceIntersects.length > 0) {
                const mesh = pieceIntersects[0].object;
                const square = mesh.userData.square;
                if (game.get(square).color === PLAYER_COLOR) { selectPiece(square); return; }
                else if (selectedSquare) { attemptMove(square); return; }
            }

            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            if (target && selectedSquare) {
                const fileIdx = Math.floor((target.x + BOARD_OFFSET + BOARD_SQUARE_SIZE/2) / BOARD_SQUARE_SIZE);
                const rankIdx = Math.floor((target.z + BOARD_OFFSET + BOARD_SQUARE_SIZE/2) / BOARD_SQUARE_SIZE);
                if (fileIdx >= 0 && fileIdx < 8 && rankIdx >= 0 && rankIdx < 8) {
                    const file = String.fromCharCode(97 + fileIdx);
                    const rank = 8 - rankIdx;
                    attemptMove(file + rank);
                }
            }
        }

        function selectPiece(square) {
            if (selectedMesh) selectedMesh.material.color.setHex(0xffffff);
            selectedSquare = square;
            selectedMesh = piecesMap[square];
            if (selectedMesh) selectedMesh.material.color.setHex(0x00ff00);
        }

        function attemptMove(targetSquare) {
            const piece = game.get(selectedSquare);
            if (piece.type === 'p' && (targetSquare[1] === '8' || targetSquare[1] === '1')) {
                const tempMove = new Chess(game.fen());
                const valid = tempMove.move({from:selectedSquare, to:targetSquare, promotion:'q'});
                if(valid) {
                    pendingPromotionMove = { from: selectedSquare, to: targetSquare };
                    document.getElementById('promo-modal').classList.add('active');
                    return;
                }
            }
            executeMove({ from: selectedSquare, to: targetSquare, promotion: 'q' });
        }

        function commitPromotion(promotionPiece) {
            document.getElementById('promo-modal').classList.remove('active');
            if (pendingPromotionMove) {
                executeMove({ 
                    from: pendingPromotionMove.from, 
                    to: pendingPromotionMove.to, 
                    promotion: promotionPiece 
                });
                pendingPromotionMove = null;
            }
        }

        function executeMove(moveObj) {
            const move = game.move(moveObj);
            if (move) {
                if(selectedMesh) selectedMesh.material.color.setHex(0xffffff);
                selectedSquare = null; selectedMesh = null;
                
                handleMoveVisuals(move, () => {
                    updateStatus();

                    if (game.in_checkmate() || game.in_draw()) {
                        if(game.in_checkmate()) playCheckmateAnimation(move);
                        else triggerGameOver();
                        return;
                    }

                    if (GAME_MODE === 'ai') {
                        if(!game.game_over()) {
                            isAIThinking = true;
                            document.getElementById('status').innerText = "AI is thinking...";
                            setTimeout(makeAIMove, 800);
                        }
                    } else if (GAME_MODE === 'pvp') {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            socket.send(JSON.stringify({
                                type: 'move',
                                roomId: ROOM_ID,
                                move: move
                            }));
                        }
                    }
                });
            }
        }

        function makeAIMove() {
            const moves = game.moves({ verbose: true });
            if (moves.length === 0) return;
            
            let bestMove = moves[Math.floor(Math.random() * moves.length)];
            const captures = moves.filter(m => m.captured);
            if (captures.length > 0) bestMove = captures[Math.floor(Math.random() * captures.length)];
            
            if (bestMove.promotion) bestMove.promotion = 'q';

            game.move(bestMove);
            handleMoveVisuals(bestMove, () => {
                isAIThinking = false;
                updateStatus();
                if (game.in_checkmate() || game.in_draw()) {
                    if (game.in_checkmate()) playCheckmateAnimation(bestMove);
                    else triggerGameOver();
                }
            });
        }

        function handleMoveVisuals(move, onComplete) {
            const originSquare = move.from;
            const destSquare = move.to;
            const pieceMesh = piecesMap[originSquare];
            const targetPos = squareToVector(destSquare);

            if (move.captured) {
                updateCaptures(move.captured, move.color);
            }

            if (move.flags && (move.flags.includes('k') || move.flags.includes('q'))) {
                let rookSrc, rookDst;
                if (move.color === 'w') {
                    rookSrc = move.flags.includes('k') ? 'h1' : 'a1';
                    rookDst = move.flags.includes('k') ? 'f1' : 'd1';
                } else {
                    rookSrc = move.flags.includes('k') ? 'h8' : 'a8';
                    rookDst = move.flags.includes('k') ? 'f8' : 'd8';
                }
                const rookMesh = piecesMap[rookSrc];
                const rookPos = squareToVector(rookDst);
                finishMove(rookMesh, rookPos, rookSrc, rookDst, null);
            }

            if (move.captured) {
                playKillVideo(move, () => {
                    const victimMesh = piecesMap[destSquare];
                    if(victimMesh) scene.remove(victimMesh);
                    if (move.promotion) {
                        scene.remove(pieceMesh);
                        spawnPiece(move.promotion, move.color, originSquare);
                        const newMesh = piecesMap[originSquare];
                        finishMove(newMesh, targetPos, originSquare, destSquare, onComplete);
                    } else {
                        finishMove(pieceMesh, targetPos, originSquare, destSquare, onComplete);
                    }
                });
            } else {
                if (move.promotion) {
                    scene.remove(pieceMesh);
                    spawnPiece(move.promotion, move.color, originSquare);
                    const newMesh = piecesMap[originSquare];
                    finishMove(newMesh, targetPos, originSquare, destSquare, onComplete);
                } else {
                    finishMove(pieceMesh, targetPos, originSquare, destSquare, onComplete);
                }
            }
        }

        function finishMove(mesh, targetPos, oldSquare, newSquare, onComplete) {
            new TWEEN.Tween(mesh.position)
                .to({ x: targetPos.x, z: targetPos.z }, 400)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => { if (onComplete) onComplete(); })
                .start();
            delete piecesMap[oldSquare];
            piecesMap[newSquare] = mesh;
            mesh.userData.square = newSquare;
        }

        function updateStatus() {
            let status = '';
            let moveColor = game.turn() === 'w' ? 'White' : 'Black';
            const statEl = document.getElementById('status');
            const alertEl = document.getElementById('check-alert');
            
            statEl.classList.remove('check');
            alertEl.style.display = 'none';
            
            const board = game.board();
            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    const p = board[r][c];
                    const sq = String.fromCharCode(97 + c) + (8 - r);
                    if (piecesMap[sq]) piecesMap[sq].material.color.setHex(0xffffff);
                }
            }

            if (game.in_check()) {
                statEl.classList.add('check');
                alertEl.style.display = 'block';
                setTimeout(() => { alertEl.style.display = 'none'; }, 2500);
                
                const turn = game.turn();
                for(let r=0; r<8; r++) {
                    for(let c=0; c<8; c++) {
                        const p = board[r][c];
                        if (p && p.type === 'k' && p.color === turn) {
                            const sq = String.fromCharCode(97 + c) + (8 - r);
                            if(piecesMap[sq]) piecesMap[sq].material.color.setHex(0xff0000);
                        }
                    }
                }
            }

            if (game.in_checkmate()) {
                status = 'CHECKMATE! ' + (moveColor==='White'?'Black':'White') + ' WINS!';
            } else if (game.in_draw()) {
                status = 'Game over, drawn position';
            } else {
                status = moveColor + ' to move';
                if (game.in_check()) status += ' (CHECK!)';
            }
            statEl.innerText = status;
        }

        function triggerGameOver() {
            let reason = "Game Over";
            if(game.in_checkmate()) {
                const winner = game.turn() === 'w' ? "BLACK" : "WHITE";
                reason = `CHECKMATE - ${winner} WINS!`;
            } else if(game.in_draw()) {
                reason = "DRAW (Stalemate / Insufficient Material)";
            }
            
            document.getElementById('end-title').innerText = reason;
            document.getElementById('end-reason').innerText = `Well fought, ${PLAYER_NAME}.`;
            
            setTimeout(() => {
                document.getElementById('game-over-modal').classList.add('active');
            }, 1000);
        }

        const overlay = document.getElementById('battle-overlay');
        const vid = document.getElementById('battle-video');
        const msg = document.getElementById('video-msg');
        const skip = document.getElementById('skip-btn');
        let onVideoEnd = null;

        skip.onclick = stopVideo;

        function playKillVideo(move, callback) {
            const attackerColor = move.color === 'w' ? 'white' : 'black';
            const victimColor = move.color === 'w' ? 'black' : 'white';
            const attackerPiece = getFullName(move.piece, move.color).split('_')[1];
            const victimPiece = getFullName(move.captured, move.color === 'w' ? 'b' : 'w').split('_')[1];
            
            const filename = `${attackerColor}_${attackerPiece}_takes_${victimColor}_${victimPiece}.mp4`;
            playVideoFile(filename, callback);
        }

        function playCheckmateAnimation(move) {
            const attackerColor = move.color === 'w' ? 'white' : 'black';
            const victimColor = move.color === 'w' ? 'black' : 'white';
            const attackerPiece = getFullName(move.piece, move.color).split('_')[1];
            const filename = `${attackerColor}_${attackerPiece}_takes_${victimColor}_king.mp4`;
            
            playVideoFile(filename, () => {
                triggerGameOver();
            });
        }

        function playVideoFile(filename, callback) {
            onVideoEnd = callback;
            const fullPath = `${ASSETS_PATH}videos/${filename}`;

            msg.innerText = `Loading: ${filename}`;
            vid.src = fullPath;
            overlay.style.display = 'flex';
            
            vid.play().then(() => {
                msg.innerText = "";
            }).catch(e => {
                msg.innerText = `VIDEO MISSING: ${filename}\n(Skipping in 1s...)`;
                setTimeout(stopVideo, 1000);
            });

            vid.onended = stopVideo;
        }

        function stopVideo() {
            vid.pause();
            overlay.style.display = 'none';
            if (onVideoEnd) {
                onVideoEnd();
                onVideoEnd = null;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            for (let key in piecesMap) {
                const mesh = piecesMap[key];
                mesh.lookAt(camera.position.x, mesh.position.y, camera.position.z);
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        <div id="chat-panel"
             style="position:fixed; bottom:10px; left:10px; width:260px; max-height:200px; background:rgba(0,0,0,0.8); border:1px solid #444; border-radius:6px; display:none; flex-direction:column; z-index:20; pointer-events:auto; font-size:12px;">
            <div style="padding:4px 8px; border-bottom:1px solid #333; color:#ccc; display:flex; justify-content:space-between; align-items:center;">
                <span>Room Chat</span>
                <span style="font-size:10px; color:#777;">[T] to focus</span>
            </div>
            <div id="chat-messages"
                 style="flex:1; padding:6px 8px; overflow-y:auto; color:#ddd; font-family:monospace;"></div>
            <div style="display:flex; gap:4px; padding:4px 4px 6px 4px;">
                <input id="chat-input"
                       type="text"
                       placeholder="type message..."
                       style="flex:1; padding:4px 6px; border-radius:4px; border:1px solid #444; background:#111; color:#eee; font-size:12px;">
                <button id="chat-send-btn"
                        style="padding:4px 8px; border-radius:4px; border:1px solid #555; background:#333; color:#eee; cursor:pointer; font-size:12px;">Send</button>
            </div>
        </div>

    </script>    
</body>
</html>
